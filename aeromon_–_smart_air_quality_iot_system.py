# -*- coding: utf-8 -*-
"""AeroMon – Smart Air Quality IoT System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o3OR4VeCzokBLLmhDBl_dThg6i_3XQrR
"""

# aeromon.py — Smart Air Quality IoT System (Colab-ready)

import sys, subprocess
def pip_install(pkg):
    subprocess.check_call([sys.executable, "-m", "pip", "install", pkg])

# Auto-install dependencies
for pkg in ["paho-mqtt", "flask", "matplotlib"]:
    try:
        __import__(pkg.split("==")[0])
    except ImportError:
        pip_install(pkg)

import os, time, json, random, sqlite3, threading
from datetime import datetime
import paho.mqtt.client as mqtt
from flask import Flask, jsonify
import matplotlib.pyplot as plt

# ---------- Config ----------
BROKER = "test.mosquitto.org"
PORT = 1883
TOPIC = "aeromon"
DB_FILE = "aeromon.db"
PUBLISH_INTERVAL = 3  # seconds

# ---------- Utils ----------
def now_str():
    return datetime.utcnow().isoformat()

# ---------- AQI Calculator ----------
def calc_aqi(pm25):
    if pm25 <= 12:
        return "Good"
    elif pm25 <= 35.4:
        return "Moderate"
    elif pm25 <= 55.4:
        return "Unhealthy for Sensitive Groups"
    elif pm25 <= 150.4:
        return "Unhealthy"
    elif pm25 <= 250.4:
        return "Very Unhealthy"
    else:
        return "Hazardous"

# ---------- Sensor Simulator ----------
class AirNode:
    def __init__(self, node_id):
        self.node_id = node_id

    def read(self):
        temp = round(random.uniform(18, 35), 1)
        hum = round(random.uniform(30, 80), 1)
        co2 = random.randint(400, 2000)
        pm25 = round(random.uniform(5, 300), 1)
        return {
            "node": self.node_id,
            "timestamp": now_str(),
            "temp": temp,
            "humidity": hum,
            "co2": co2,
            "pm25": pm25,
            "aqi": calc_aqi(pm25)
        }

# ---------- MQTT Publisher ----------
class NodePublisher(threading.Thread):
    def __init__(self, node):
        super().__init__(daemon=True)
        self.node = node
        self.client = mqtt.Client()
        self.running = True

    def run(self):
        self.client.connect(BROKER, PORT, 60)
        self.client.loop_start()
        topic = f"{TOPIC}/{self.node.node_id}"
        while self.running:
            data = self.node.read()
            self.client.publish(topic, json.dumps(data))
            print(f"[PUB-{self.node.node_id}] {data}")
            time.sleep(PUBLISH_INTERVAL)

    def stop(self):
        self.running = False
        self.client.loop_stop()
        self.client.disconnect()

# ---------- SQLite Store ----------
class DataStore:
    def __init__(self, db=DB_FILE):
        self.db = db
        self._init_db()

    def _init_db(self):
        conn = sqlite3.connect(self.db)
        conn.execute("""
        CREATE TABLE IF NOT EXISTS readings (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            node TEXT,
            timestamp TEXT,
            temp REAL,
            humidity REAL,
            co2 INTEGER,
            pm25 REAL,
            aqi TEXT
        )
        """)
        conn.commit()
        conn.close()

    def insert(self, data):
        conn = sqlite3.connect(self.db)
        conn.execute("""
        INSERT INTO readings (node, timestamp, temp, humidity, co2, pm25, aqi)
        VALUES (?, ?, ?, ?, ?, ?, ?)
        """, (data["node"], data["timestamp"], data["temp"], data["humidity"], data["co2"], data["pm25"], data["aqi"]))
        conn.commit()
        conn.close()

    def recent(self, limit=10):
        conn = sqlite3.connect(self.db)
        rows = conn.execute("SELECT * FROM readings ORDER BY id DESC LIMIT ?", (limit,)).fetchall()
        conn.close()
        return rows

# ---------- MQTT Collector ----------
class DataCollector:
    def __init__(self, store):
        self.store = store
        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message

    def on_connect(self, client, userdata, flags, rc):
        print("[Collector] Connected, subscribing...")
        client.subscribe(f"{TOPIC}/+")

    def on_message(self, client, userdata, msg):
        data = json.loads(msg.payload.decode())
        self.store.insert(data)
        print("[Collector] Saved:", data)

    def start(self):
        self.client.connect(BROKER, PORT, 60)
        self.client.loop_start()

    def stop(self):
        self.client.loop_stop()
        self.client.disconnect()

# ---------- Flask API ----------
def create_api(store):
    app = Flask(__name__)

    @app.route("/recent")
    def recent():
        return jsonify(store.recent())

    return app

# ---------- Dashboard ----------
def generate_dashboard(store, out_file="aqi_chart.png"):
    data = store.recent(50)
    if not data:
        print("No data for dashboard.")
        return
    times = [row[2] for row in data][::-1]
    pm25_values = [row[6] for row in data][::-1]
    plt.figure(figsize=(10,5))
    plt.plot(times, pm25_values, marker="o")
    plt.xticks(rotation=45, ha="right")
    plt.xlabel("Time")
    plt.ylabel("PM2.5 (µg/m³)")
    plt.title("Air Quality Trend")
    plt.tight_layout()
    plt.savefig(out_file)
    print(f"Dashboard saved as {out_file}")

# ---------- Main ----------
if __name__ == "__main__":
    store = DataStore()
    nodes = [NodePublisher(AirNode(f"node{i}")) for i in range(1, 3)]
    for n in nodes: n.start()
    collector = DataCollector(store)
    collector.start()

    app = create_api(store)
    threading.Thread(target=lambda: app.run(host="0.0.0.0", port=5000), daemon=True).start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        for n in nodes: n.stop()
        collector.stop()
        generate_dashboard(store)